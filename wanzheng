```python
project_root/
├─ app/
│   ├─ models.py
│   ├─ handlers.py
│   ├─ auth.py
│   └─ main.py
└─ requirements.txt
```

```python
# auth.py
import jwt
import functools
from jwt.exceptions import InvalidTokenError
from models import User
from tornado.web import HTTPError
import configparser

config = configparser.ConfigParser()
config.read('config.ini')

SECRET_KEY = config['app']['secret_key']


def jwt_required(handler_func):
    @functools.wraps(handler_func)
    async def wrapper(handler, *args, **kwargs):
        auth_header = handler.request.headers.get("Authorization")
        if not auth_header or "Bearer" not in auth_header:
            raise HTTPError(status_code=401, reason="Missing or invalid token")

        token = auth_header.split(" ")[1]
        try:
            decoded = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
            user_id = decoded.get("user_id")
            user = User.get_or_none(User.id == user_id)

            if not user:
                raise HTTPError(status_code=401, reason="Invalid token")
        except InvalidTokenError:
            raise HTTPError(status_code=401, reason="Invalid token")

        handler.current_user = user
        return await handler_func(handler, *args, **kwargs)

    return wrapper
```

```python
[database]
name = user_auth.db

[app]
secret_key = replace_with_your_secret_key
token_expiration_time = 86400

[server]
port = 8888
```

```python
# handlers.py
import jwt
import tornado
from tornado.escape import json_decode
from models import User, UserAuth, db
from datetime import datetime, timedelta
from peewee import IntegrityError, DoesNotExist
import configparser
from werkzeug.security import generate_password_hash, check_password_hash
from auth import jwt_required

config = configparser.ConfigParser()
config.read('config.ini')

SECRET_KEY = config['app']['secret_key']
TOKEN_EXPIRATION_TIME = int(config['app']['token_expiration_time'])


class RegisterHandler(tornado.web.RequestHandler):
    async def post(self):
        data = json_decode(self.request.body)
        email = data.get('email')
        phone = data.get('phone')
        wechat = data.get('wechat')
        password = data.get('password')

        if email:
            auth_type = 'email'
            identifier = email
            existing_user = User.get_or_none(User.email == email)
        elif phone:
            auth_type = 'phone'
            identifier = phone
            existing_user = User.get_or_none(User.phone == phone)
        elif wechat:
            auth_type = 'wechat'
            identifier = wechat
            existing_user = User.get_or_none(User.nickname == wechat)
        else:
            self.set_status(400)
            self.write({'error': 'Invalid registration data'})
            return

        if existing_user:
            self.set_status(400)
            self.write({'error': 'A user with this identifier already exists'})
            return

        try:
            with db.atomic():
                hashed_password = generate_password_hash(password)  # Hash the password here
                user = User.create(
                    nickname=identifier,
                    email=email if auth_type == 'email' else None,
                    phone=phone if auth_type == 'phone' else None,
                    password=hashed_password
                )
                UserAuth.create(user=user, auth_type=auth_type, identifier=identifier, credential=hashed_password)
                self.write({"user_id": user.id, "nickname": user.nickname, "avatar": user.avatar,
                            "created_at": user.created_at.isoformat()})
        except IntegrityError as e:
            self.set_status(400)
            self.write({'error': str(e)})


class LoginHandler(tornado.web.RequestHandler):
    async def post(self):
        data = json_decode(self.request.body)
        email = data.get('email')
        phone = data.get('phone')
        wechat = data.get('wechat')
        password = data.get('password')

        if email:
            auth_type = 'email'
            identifier = email
        elif phone:
            auth_type = 'phone'
            identifier = phone
        elif wechat:
            auth_type = 'wechat'
            identifier = wechat
        else:
            self.set_status(400)
            self.write({'error': 'Invalid login data'})
            return

        try:
            user_auth = UserAuth.get(UserAuth.auth_type == auth_type, UserAuth.identifier == identifier)
            user = user_auth.user
            if auth_type != 'wechat':
                if check_password_hash(user.password, password):
                    token = jwt.encode(
                        {"user_id": user.id, "exp": datetime.utcnow() + timedelta(seconds=TOKEN_EXPIRATION_TIME)},
                        SECRET_KEY, algorithm="HS256")
                    self.write({"user_id": user.id, "nickname": user.nickname, "avatar": user.avatar,
                                "created_at": user.created_at.isoformat(), "token": token})
                else:
                    self.set_status(401)
                    self.write({"error": "Invalid credentials"})
            else:
                token = jwt.encode(
                    {"user_id": user.id, "exp": datetime.utcnow() + timedelta(seconds=TOKEN_EXPIRATION_TIME)},
                    SECRET_KEY, algorithm="HS256")
                self.write({"user_id": user.id, "nickname": user.nickname, "avatar": user.avatar,
                            "created_at": user.created_at.isoformat(), "token": token})
        except UserAuth.DoesNotExist:
            self.set_status(401)
            self.write({"error": "User not found"})


class ChangeNicknameHandler(tornado.web.RequestHandler):
    @jwt_required
    async def post(self):
        data = json_decode(self.request.body)
        new_nickname = data.get('new_nickname')

        try:
            with db.atomic():
                self.current_user.nickname = new_nickname
                self.current_user.updated_at = datetime.now()
                self.current_user.save()

                self.write({"message": "Nickname updated successfully"})
        except IntegrityError:
            self.set_status(400)
            self.write({"error": "This nickname has already been taken"})


class ChangeAvatarHandler(tornado.web.RequestHandler):
    @jwt_required
    async def post(self):
        data = json_decode(self.request.body)
        new_avatar = data.get('new_avatar')

        try:
            with db.atomic():
                self.current_user.avatar = new_avatar
                self.current_user.updated_at = datetime.now()
                self.current_user.save()

                self.write({"message": "Avatar updated successfully"})
        except Exception as e:
            self.set_status(400)
            self.write({'error': str(e)})


class DeleteAvatarHandler(tornado.web.RequestHandler):
    @jwt_required
    async def post(self):
        try:
            with db.atomic():
                self.current_user.avatar = None
                self.current_user.updated_at = datetime.now()
                self.current_user.save()

                self.write({"message": "Avatar deleted successfully"})
        except Exception as e:
            self.set_status(400)
            self.write({'error': str(e)})


class ChangePhoneHandler(tornado.web.RequestHandler):
    @jwt_required
    async def post(self):
        data = json_decode(self.request.body)
        new_phone = data.get('new_phone')

        try:
            with db.atomic():
                # Get user's credential for auth_type 'email'
                user_auth_email = UserAuth.get(user=self.current_user, auth_type='email')

                user_auth_phone, created = UserAuth.get_or_create(
                    auth_type='phone', user=self.current_user,
                    defaults={'identifier': new_phone, 'credential': user_auth_email.credential})
                if not created:
                    user_auth_phone.identifier = new_phone
                user_auth_phone.updated_at = datetime.now()
                user_auth_phone.save()

                self.current_user.phone = new_phone
                self.current_user.updated_at = datetime.now()
                self.current_user.save()

                self.write({"message": "Phone number updated successfully"})
        except IntegrityError:
            self.set_status(400)
            self.write({"error": "This phone number has already been taken"})


class ChangeEmailHandler(tornado.web.RequestHandler):
    @jwt_required
    async def post(self):
        data = json_decode(self.request.body)
        new_email = data.get('new_email')

        try:
            with db.atomic():
                # Get user's credential for auth_type 'phone'
                user_auth_phone = UserAuth.get(user=self.current_user, auth_type='phone')

                user_auth_email, created = UserAuth.get_or_create(
                    auth_type='email', user=self.current_user,
                    defaults={'identifier': new_email, 'credential': user_auth_phone.credential})
                if not created:
                    user_auth_email.identifier = new_email
                user_auth_email.updated_at = datetime.now()
                user_auth_email.save()

                self.current_user.email = new_email
                self.current_user.updated_at = datetime.now()
                self.current_user.save()

                self.write({"message": "Email updated successfully"})
        except IntegrityError:
            self.set_status(400)
            self.write({"error": "This email has already been taken"})

```

```python
# main.py
import tornado.web
import tornado.ioloop
from handlers import RegisterHandler, LoginHandler, ChangeAvatarHandler, DeleteAvatarHandler, ChangePhoneHandler, \
    ChangeNicknameHandler
import configparser

config = configparser.ConfigParser()
config.read('config.ini')


def make_app():
    return tornado.web.Application([
        (r"/register", RegisterHandler),
        (r"/login", LoginHandler),
        (r"/change_avatar", ChangeAvatarHandler),
        (r"/delete_avatar", DeleteAvatarHandler),
        (r"/change_phone", ChangePhoneHandler),
        (r"/change_nickname", ChangeNicknameHandler),
    ])


if __name__ == "__main__":
    app = make_app()
    app.listen(8888)
    tornado.ioloop.IOLoop.current().start()
```

```python
# models.py
import peewee as pw
from datetime import datetime
from peewee import Model, SqliteDatabase, CharField, AutoField, DateTimeField, ForeignKeyField
from werkzeug.security import generate_password_hash, check_password_hash
import configparser

config = configparser.ConfigParser()
config.read('config.ini')

db = SqliteDatabase(config['database']['name'])


class BaseModel(Model):
    class Meta:
        database = db


class User(BaseModel):
    id = AutoField()
    nickname = CharField(max_length=100)
    email = pw.CharField(max_length=255, unique=True, null=True)
    phone = pw.CharField(max_length=20, unique=True, null=True)
    password = pw.CharField(max_length=255)
    avatar = CharField(max_length=255, null=True)
    created_at = DateTimeField(default=datetime.now)
    updated_at = DateTimeField(null=True)

    def set_avatar(self, avatar_url):
        self.avatar = avatar_url
        self.save()

    def delete_avatar(self):
        self.avatar = None
        self.save()

    def change_phone(self, new_phone):
        self.phone = new_phone
        self.save()

    def change_nickname(self, new_nickname):
        self.nickname = new_nickname
        self.save()


class UserAuth(BaseModel):
    id = AutoField()
    user = ForeignKeyField(User, backref='auths')
    auth_type = pw.CharField(max_length=20)
    identifier = pw.CharField(max_length=255)
    credential = CharField(max_length=255)
    created_at = DateTimeField(default=datetime.now)
    updated_at = DateTimeField(null=True)

    def set_password(self, password: str):
        self.credential = generate_password_hash(password)

    def verify_password(self, password: str):
        return check_password_hash(self.credential, password)

    def check_password(self, password):
        return check_password_hash(self.credential, password)

    class Meta:
        # ... your existing code ...
        indexes = (
            # Create a unique index on auth_type + identifier
            (('auth_type', 'identifier'), True),
        )


db.connect()
db.create_tables([User, UserAuth])
```

